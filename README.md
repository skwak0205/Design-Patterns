# Java Design Pattern

### 1. Singleton Pattern

- 클래스를 생성하는 인스턴스가 오직하나여야 하며, 인스턴스 접근 혹은 생성 역시 한가지의 방식으로 제공
- getInstance() 메소드를 통해 오직 하나의 객체(인스턴스)만 생성이 되고, 어떤 클라이언트든 같은 인스턴스를 참조함
- 활용
  - 클래스 인스턴스가 오직 하나여야 함을 보장하는 곳
  - 모든 클라이언트가 하나의 인스턴스만 사용해야 하는 경우
- 만드는 방법
  1. Private 생성자
  2. Private static 인스턴스 변수
  3. Public static getInstance() method 구현

### 2. Strategy Pattern

- 여러 알고리즘을 **하나의 추상적인 접근점(Interface)**을 만들어 접근점에서 서로 교환 가능하도록 하는 패턴
- 의도
  - 다양한 알고리즘이 있을 때, 이들을 각각의 클래스로 캡슐화하여 만들고, 알고리즘 대체가 가능하도록 할 때
- 활용
  - 알고리즘 행위가 조금씩 다를 뿐, 개념적으로 관련된 많은 클래스들이 존재할 때
  - 알고리즘 변형이 빈번하게 필요한 경우
- 예제
  - 많은 데이터를 검색할 때, 상황에 따라 다양한 정렬 알고리즘을 바꿔가면서 적용하려고 함
- 특징
  - 관련 알고리즘 집합을 형성할 수 있음
  - 알고리즘의 선택 혹은 대체가 가능함
  - 알고리즘 객체 수가 증가함

### 3. Adapter Pattern

- 서로 다른 인터페이스를 가진 두 클래스를 어댑터 클래스로 인터페이스를 통일 시켜 사용하는 방법

- 의도
  - 이미 제공되는 기능이 형태가 달라, 필요로 하는 형태로 변경하고자 할 때
- 활용
  - 기존의 클래스를 사용해야 하나 인터페이스가 수정되어야 하는 경우
  - 기존 라이브러리 모양을 달리하여 재사용하고자 할 경우

### 4. Template Method Pattern

- 상위 클래스가 뼈대가 되는 로직을 구성하고, 하위 클래스들이 이 로직의 요소들을 각각 구현하는 패턴

- 알고리즘의 구조를 메소드에 정의하고 하위 클래스에서 알고리즘 구조의 변경없이 알고리즘을 재정의 하는 패턴
- 단계
  1. 알고리즘을 여러 단계로 나눔
  2. 나눠진 알고리즘의 단계를 메소드로 선언
  3. 알고리즘을 수행할 템플릿 메소드를 만듦
  4. 하위 클래스에서 나눠진 메소드들을 구현

### 5. Factory Method Pattern

- 인터페이스로 객체들을 정의하고, 팩토리가 인스턴스를 생성하는 패턴

- 개발자는 객체를 사용해야 하는데, 어떤 객체를 생성할지 혹은, 어떤 객체가 생성 가능한지 알 수 없을 때 사용
- 활용
  - 생성할 객체 타입을 예측할 수 없을 때
  - 객체 생성의 책임을 하위 클래스에게 위임시키고, 어느 하위 클래스에게 위임했는지에 대한 정보를 은닉하고자 할 때

### 6. Prototype Pattern

- 기존의 인스턴스를 그대로 복제(clone)하여 새로운 객체를 생성하는 방법 - 하나의 인스턴스를 사용하는 싱글톤과는 반대되는 개념

- 생산 비용이 높은 인스턴스를 복사를 통해 쉽게 생성 할 수 있도록 하는 패턴
- 인스턴스 생산 비용이 높은 경우
  1. 종류가 너무 많아서 클래스로 정리되지 않는 경우
  2. 클래스로부터 인스턴스 생성이 어려운 경우

### 7. Builder Pattern

- 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴

- 복잡한 단계가 필요한 인스턴스 생성을 빌더 패턴을 통해 구현

### 8. Abstract Factory Pattern

- 기존 팩토리 메소드 방식에서 팩토리의 상위 팩토리를 통해 구체적인 팩토리 생성

- 구체적인 클래스를 알지 못하고, 서로 관련성이 있으나, 독립적인 여러 객체 군을 생성하기 위한 인터페이스 제공하기 위해 사용

### 9. Bridge Pattern

- 구현부에서 추상층을 분리하여 각자 독립적으로 변형 및 확장이 가능하도록 만드는 패턴
- 기능과 구현에 대해 두개의 별도의 클래스로 구현

### 10. Composite Pattern

- 단일 객체와 그 객체들을 가지는 집합 객체를 같은 타입으로 취급하며, 트리 구조로 객체들을 엮는 패턴

### 11. Decorator Pattern

- 기본 객체에 추가적인 기능을 동적으로 유연하게 첨가하는 패턴
- 어떤 객체에 독립적인 기능을 계속해서 추가하면서 확장하고 싶을 때 사용

### 12. Visitor Pattern

- 방문자와 방문 공간을 분리하여, 방문 공간이 방문자를 맞이할 때, 이후에 대한 행동을 방문자에게 위임하는 패턴

- 자료 구조(데이터)와 자료 구조를 처리하는 로직(알고리즘)을 분리해야 할 경우 혹은 데이터 구조보다 알고리즘이 더 자주 바뀌는 경우 사용

### 13. Chain of Responsibility

- 책임 사슬(연쇄) 패턴
- 요청을 처리하는 동일 인터페이스 객체들을 체인 형태로 연결해 놓는 패턴
- 앞의 객체의 요청을 처리하지 못할 경우, 같은 인터페이스의 다른 객체에게 해당 요청을 전달

### 14. Facade Pattern

- 퍼사드 패턴
- 어떤 서브 시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공
- 퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브 시스템을 더 쉽게 사용할 수 있음

### 15. Observer Pattern

- 하나의 관찰대상 - 여러 개의 관찰자 구조가 필요할 때 쓰는 패턴
- 이벤트 핸들러가 대표적인 옵저버 패턴의 예

### 16. Mediator Pattern

- 중재자 패턴
- 모든 클래스간의 복잡한 로직(상호작용)을 캡슐화하여 하나의 클래스에 위임하여 처리하는 패턴
- M:N의 관계에서 M:1의 관계로 복잡도를 떨어뜨려 유지보수 및 확장성에 유리

### 17. State Pattern

- 상태 패턴은 상태 자체를 객체화함으로써, 상태에 따른 액션도 상태 객체에 내부에 구현하는 패턴

### 18. Memento Pattern

- 상태 패턴은 상태 자체를 객체화함으로써, 상태에 따른 액션도 상태 객체에 내부에 구현하는 패턴

### 19. Flyweight Pattern

- 어떤 클래스의 인스턴스 한 개만 가지고 여러 개의 '가상 인스턴스'를 제공하고 싶을 때 사용하는 패턴
- 인스턴스를 가능한 대로 공유시켜 쓸데없이 new 연산자를 통한 메모리 낭비를 줄이는 방식

### 20. Proxy Pattern

- 프록시 객체를 통해 기본 객체에 접근하는 패턴
- 어떤 객체에 대한 접근을 제어하기 위한 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴

### 21. Command Pattern

- 어떤 객체에 대한 접근을 제어하기 위한 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴

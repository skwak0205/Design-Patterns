# Java Design Pattern

### 1. Singleton Pattern

- getInstance() 메소드를 통해 오직 하나의 객체(인스턴스)만 생성이 되고, 어떤 클라이언트든 같은 인스턴스를 참조함
- 만드는 방법
  1. Private 생성자
  2. Private static 인스턴스 변수
  3. Public static getInstance() method 구현

### 2. Strategy Pattern

- 여러 알고리즘을 하나의 추상적인 접근점(Interface)을 만들어 접근점에서 서로 교환 가능하도록 하는 패턴
- 특징
  - 관련 알고리즘 집합을 형성할 수 있음
  - 알고리즘의 선택 혹은 대체가 가능함
  - 알고리즘 객체 수가 증가함

### 3. Adapter Pattern

- 의도
  - 이미 제공되는 기능이 형태가 달라, 필요로 하는 형태로 변경하고자 할 때
- 활용
  - 기존의 클래스를 사용해야 하나 인터페이스가 수정되어야 하는 경우
  - 기존 라이브러리 모양을 달리하여 재사용하고자 할 경우

### 4. Template Method Pattern

- 알고리즘의 구조를 메소드에 정의하고 하위 클래스에서 알고리즘 구조의 변경없이 알고리즘을 재정의 하는 패턴
- 단계
  1. 알고리즘을 여러 단계로 나눔
  2. 나눠진 알고리즘의 단계를 메소드로 선언
  3. 알고리즘을 수행할 템플릿 메소드를 만듦
  4. 하위 클래스에서 나눠진 메소드들을 구현

### 5. Factory Method Pattern

- 개발자는 객체를 사용해야 하는데, 어떤 객체를 생성할지 혹은, 어떤 객체가 생성 가능한지 알 수 없을 때 사용
- 활용
  - 생성할 객체 타입을 예측할 수 없을 때
  - 객체 생성의 책임을 하위 클래스에게 위임시키고, 어느 하위 클래스에게 위임했는지에 대한 정보를 은닉하고자 할 때

### 6. Prototype Pattern

- 생산 비용이 높은 인스턴스를 복사를 통해 쉽게 생성 할 수 있도록 하는 패턴
- 인스턴스 생산 비용이 높은 경우
  1. 종류가 너무 많아서 클래스로 정리되지 않는 경우
  2. 클래스로부터 인스턴스 생성이 어려운 경우

### 7. Builder Pattern

- 복잡한 단계가 필요한 인스턴스 생성을 빌더 패턴을 통해 구현
- 복잡한 단계를 거쳐야 생성되는 객체의 구현을 서브 클래스에게 넘겨주는 패턴

### 8. Abstract Factory Pattern

- 구체적인 클래스를 알지 못하고, 서로 관련성이 있으나, 독립적인 여러 객체 군을 생성하기 위한 인터페이스 제공하기 위해 사용
